
######[ get_dummies, to_categorical, OneHotEncoder  차이점 정리 ]# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 









# [ to_categorical ]


# get_dummies은 원래 데이터의 값이 [0, 2, 3, 6, 1, 9, 20, 1]일 경우 0 1 2 3 6 9 20 형식으로 라벨 이름을 만들지만
# to_categorical은 [0, 2, 3, 6, 1, 9, 20, 1]일 경우 0 1 2 3 ..... 18 19 20 형식으로 다 채워서 출력한다.


# 그리고 to_categorical은 아래 형태처럼 다차원[리스트가 여러개]인 형태로 출력해주며 값이 있는 부분을 0과 1로 채워주는
# 역할이므로 문자나 값이 큰 값을 0과 1로 만들어주면서 리스트를 만들어 주기에 이럴경우 활용하면 좋다.
# [[0. 0. 1. 0. 0. 0. 0. 0.]
#  [0. 0. 1. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 1.]
#  [0. 0. 0. 0. 1. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 1. 0. 0.]]


"""===[ to_categorical 사용 ]==================================================================================================================

from tensorflow.keras.utils import to_categorical 
# 1. 데이터

y = np.array([2, 2, 7, 4, 5])

 -  원래 데이터

print(y)
[2 2 7 4 5]

- - - - - - - - - - - - - - - - - -

 -   y = to_categorical(y)
 
print(y)
[[0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]]

y의 데이터중 제일 큰 라벨 값이 7이므로 스칼라는 0~7까지 총 8개의 스칼라가 생겼으며 백터는 데이터의
갯수 만큼 5개가 생김

-[ to_categorical 추가설명 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

categorical()의 괄호 안에 데이터중 가장 값이 큰 것을 기준으로 스칼라의 범위가 정해지며 기존 스칼라의 갯수만큼
백터가 생긴다. 값의 해당 위치는 1 나머지는 0으로 채워줌

무조건 0부터 시작한다 (0이 없으면 만들어서 채움) (앞을 채워줘야 하는 경우 요놈 쓰면 좋음)









































[ get_dummies ]

get_dummies는 아래 데이터처럼 일차원[리스트가 하나]인 경우에만 사용이 가능하다 사용할 일은 없었지만 아래 데이터를
다시 일차원으로 돌리면서 0과 1데이터로 만들고 싶으면 np.argmax를  get_dummies 사용후에 사용하면 가능하다.

[2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 1 1 1 2 2 2 0 2 0 1 2 1 0 1 2]

 - 직접 만든 원래 데이터
[0, 2, 3, 6, 1, 9, 20, 1]


 - get_dummies 사용후

   0   1   2   3   6   9   20
0   1   0   0   0   0   0   0
1   0   0   1   0   0   0   0
2   0   0   0   1   0   0   0
3   0   0   0   0   1   0   0
4   0   1   0   0   0   0   0
5   0   0   0   0   0   1   0
6   0   0   0   0   0   0   1
7   0   1   0   0   0   0   0




===[ get_dummies ]=====================================================================================================================

from pandas import get_dummies
# y = get_dummies(y)
# print(y)           # y값 보면 행 0~177 열 유니크값 대로 0 1 2  마지막에 [178 rows x 3 columns] 까지 표시해줌
# print(y.shape)     # (178, 3)
# y의 label 값을 유니크값 만큼만 변환해주는데 print(y)해보면 라벨값이랑 인덱스정보가 들어가 있음

***[주의사항]******************
get_dummies를 사용할 때 데이터는 1차원 데이터 즉 리스트가 하나인 데이터만 사용 가능하다. 그렇지 않을 경우!
ValueError: Data must be 1-dimensional 라는 에러가 발생한다.

---[ get_dummies 해당 데이터에서 사용 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 - 원래 y의 데이터
 
print(y) 
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]

- - -- - - - - - - - - - - - -

- get_dummies() 사용후

y = get_dummies(y)

print(y) 
     0  1  2
0    1  0  0
1    1  0  0
2    1  0  0
3    1  0  0
4    1  0  0
..  .. .. ..
145  0  0  1
146  0  0  1
147  0  0  1
148  0  0  1
149  0  0  1

[150 rows x 3 columns]

---[ get_dummies 데이터 다른 걸로 해보기 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 - 직접 만든 원래 데이터
[0, 2, 3, 6, 1, 9, 20, 1]

- - - - - - - - - - - - - - - -

 - get_dummies 사용후

   0   1   2   3   6   9   20
0   1   0   0   0   0   0   0
1   0   0   1   0   0   0   0
2   0   0   0   1   0   0   0
3   0   0   0   0   1   0   0
4   0   1   0   0   0   0   0
5   0   0   0   0   0   1   0
6   0   0   0   0   0   0   1
7   0   1   0   0   0   0   0









































[ OneHotEncoder ]

 - OneHotEncoder 사용전

[0 0 1 2 1]


 - OneHotEncoder 사용후
[[1. 0. 0.]
 [1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]
 [0. 1. 0.]]
 

===[ OneHotEncoder ]=====================================================================================================================

from sklearn.preprocessing import OneHotEncoder
# enco = OneHotEncoder(sparse=False) # <-- 이렇게 선언 해주고 
# sparse=True가 디폴트이며 이는 Metrics를 반환함 원핫인코딩에서 필요한 것은 array이므로 sparse 옵션에 False를 넣어줌
# y = enco.fit_transform(y.reshape(-1,1)) # 2차원변환을 해주려면 행의 자리에 -1넣고 열의 자리에는 열의 개수대로 넣어주면 됨. 그러면 세로베열됨 (가로배열은(1,-1)임)
# print(y)            # y값 보면 그냥 그안에 담긴 값만 딱 나옴  
# print(y.shape)      # (178, 3)
# y의 label 값을 유니크값 만큼만 변환해줌


===[ OneHotEncoder ]==================================================================================================

from sklearn.preprocessing import OneHotEncoder
# enco = OneHotEncoder(sparse=False) # <-- 이렇게 선언 해주고 
# sparse=True가 디폴트이며 이는 Metrics를 반환함 원핫인코딩에서 필요한 것은 array이므로 sparse 옵션에 False를 넣어줌
# y = enco.fit_transform(y.reshape(-1,1)) # 2차원변환을 해주려면 행의 자리에 -1넣고 열의 자리에는 열의 개수대로 
                                            넣어주면 됨. 그러면 세로베열됨 (가로배열은(1,-1)임)
# print(y)            # y값 보면 그냥 그안에 담긴 값만 딱 나옴  
# print(y.shape)      # (178, 3)
# y의 label 값을 유니크값 만큼만 변환해줌

 - 원래 데이터

[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
 
 - OneHotEncoder 사용후
 
[[1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [1. 0. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]]











































































"""
#===========================================================================================================

######[ get_dummies와 to_categorical 차이점 정리 ]# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

# get_dummies은 원래 데이터의 값이 [0, 2, 3, 6, 1, 9, 20, 1]일 경우 0 1 2 3 6 9 20 형식으로 라벨 이름을 만들지만
# to_categorical은 [0, 2, 3, 6, 1, 9, 20, 1]일 경우 0 1 2 3 ..... 18 19 20 형식으로 다 채워서 출력한다.

# 그리고 to_categorical은 아래 형태처럼 다차원[리스트가 여러개]인 형태로 출력해주며 값이 있는 부분을 0과 1로 채워주는
# 역할이므로 문자나 값이 큰 값을 0과 1로 만들어주면서 리스트를 만들어 주기에 이럴경우 활용하면 좋다.
# [[0. 0. 1. 0. 0. 0. 0. 0.]
#  [0. 0. 1. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 1.]
#  [0. 0. 0. 0. 1. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 1. 0. 0.]]

# 그리고 get_dummies는 아래 데이터처럼 일차원[리스트가 하나]인 경우에만 사용이 가능하다 사용할 일은 없었지만 아래 데이터를
# 다시 일차원으로 돌리면서 0과 1데이터로 만들고 싶으면 np.argmax를  get_dummies 사용후에 사용하면 가능하다.

# [2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 1 1 1 2 2 2 0 2 0 1 2 1 0 1 2]

#  - 직접 만든 원래 데이터
# [0, 2, 3, 6, 1, 9, 20, 1]


#  - get_dummies 사용후

#    0   1   2   3   6   9   20
# 0   1   0   0   0   0   0   0
# 1   0   0   1   0   0   0   0
# 2   0   0   0   1   0   0   0
# 3   0   0   0   0   1   0   0
# 4   0   1   0   0   0   0   0
# 5   0   0   0   0   0   1   0
# 6   0   0   0   0   0   0   1
# 7   0   1   0   0   0   0   0
"""




======[ to_categorical 사용 ]==================================================================================================================

from tensorflow.keras.utils import to_categorical 
# 1. 데이터

y = np.array([2, 2, 7, 4, 5])

 -  원래 데이터

print(y)
[2 2 7 4 5]

- - - - - - - - - - - - - - - - - -

 -   y = to_categorical(y)
 
print(y)
[[0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]]

y의 데이터중 제일 큰 라벨 값이 7이므로 스칼라는 0~7까지 총 8개의 스칼라가 생겼으며 백터는 데이터의
갯수 만큼 5개가 생김

-[ to_categorical 추가설명 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

categorical()의 괄호 안에 데이터중 가장 값이 큰 것을 기준으로 스칼라의 범위가 정해지며 기존 스칼라의 갯수만큼
백터가 생긴다. 값의 해당 위치는 1 나머지는 0으로 채워줌

무조건 0부터 시작한다 (0이 없으면 만들어서 채움) (앞을 채워줘야 하는 경우 요놈 쓰면 좋음)

===[ OneHotEncoder ]=====================================================================================================================

from sklearn.preprocessing import OneHotEncoder
# enco = OneHotEncoder(sparse=False) # <-- 이렇게 선언 해주고 
# sparse=True가 디폴트이며 이는 Metrics를 반환함 원핫인코딩에서 필요한 것은 array이므로 sparse 옵션에 False를 넣어줌
# y = enco.fit_transform(y.reshape(-1,1)) # 2차원변환을 해주려면 행의 자리에 -1넣고 열의 자리에는 열의 개수대로 넣어주면 됨. 그러면 세로베열됨 (가로배열은(1,-1)임)
# print(y)            # y값 보면 그냥 그안에 담긴 값만 딱 나옴  
# print(y.shape)      # (178, 3)
# y의 label 값을 유니크값 만큼만 변환해줌



===[ get_dummies ]=====================================================================================================================

from pandas import get_dummies
# y = get_dummies(y)
# print(y)           # y값 보면 행 0~177 열 유니크값 대로 0 1 2  마지막에 [178 rows x 3 columns] 까지 표시해줌
# print(y.shape)     # (178, 3)
# y의 label 값을 유니크값 만큼만 변환해주는데 print(y)해보면 라벨값이랑 인덱스정보가 들어가 있음

***[주의사항]******************
get_dummies를 사용할 때 데이터는 1차원 데이터 즉 리스트가 하나인 데이터만 사용 가능하다. 그렇지 않을 경우!
ValueError: Data must be 1-dimensional 라는 에러가 발생한다.

---[ get_dummies 해당 데이터에서 사용 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 - 원래 y의 데이터
 
print(y) 
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]

- - -- - - - - - - - - - - - -

- get_dummies() 사용후

y = get_dummies(y)

print(y) 
     0  1  2
0    1  0  0
1    1  0  0
2    1  0  0
3    1  0  0
4    1  0  0
..  .. .. ..
145  0  0  1
146  0  0  1
147  0  0  1
148  0  0  1
149  0  0  1

[150 rows x 3 columns]

---[ get_dummies 데이터 다른 걸로 해보기 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 - 직접 만든 원래 데이터
[0, 2, 3, 6, 1, 9, 20, 1]

- - - - - - - - - - - - - - - -

 - get_dummies 사용후

   0   1   2   3   6   9   20
0   1   0   0   0   0   0   0
1   0   0   1   0   0   0   0
2   0   0   0   1   0   0   0
3   0   0   0   0   1   0   0
4   0   1   0   0   0   0   0
5   0   0   0   0   0   1   0
6   0   0   0   0   0   0   1
7   0   1   0   0   0   0   0

===[ np.unique 설명  ]==================================================================================================
a = np.array([1, 2, 6, 4, 2, 3, 2])
values, counts = np.unique(a, return_counts=True)
values
array([1, 2, 3, 4, 6])      # 같은 값을 가진 숫자를 제거함  (중복이 안된 숫자만 있는 것이 해당 리스트의 유니크값이다.)
counts
array([1, 3, 1, 1, 1])      # 같은 값을 가진 값들의 숫자를 count해서 알려준다
[1이 1개  /  2가 3개  /  3이 1개  /  4가 1개  /  6이 1개]

===[ OneHotEncoder ]==================================================================================================

from sklearn.preprocessing import OneHotEncoder

===[ np.argmax 설명 ]==================================================================================================



# 근데 우리는 평가 단계에서 x_test와 y_test를 가지고 평가 (model.evaluate)를 해줘야 하는데
# 이 두개를 비교하면 비교가 되지 않음. 왜?
# acc 스코어는 딱 떨어지는 정수값을 비교 시켜야 하니까. 왜?
# acc 스코어는 두개를 비교해서 얼마나 잘 맞췄는지를 보여주는 '평가지표'라서.

# 그래서 여기서 numpy 배열에서 가장 높은 값을 가진 값의 인덱스(위치)를 반환해주는 함수인 
# np.argmax 가 필요함 (여기서 np에는 다른 변수값을 넣어도 상관없다고 썜이 그러심) 
# np.argmax 라는 것을 하게 되면 그 위치의 최고값을 숫자로 바꿔줌 그래서 y_test = np.argmax(y_test, axis=1)를 해보면
# [1 1 1 0 1 1 0 0 0 2 2 2 0 2 2 0 1 1 2 2 0 1 1 2 1 2 0 0 2 2] <-- 이렇게 위치 값이 나옴
                                              axis=1은 열을 따라 열을 기준으로 최대값을 뽑아준다는 뜻이다.

ex)[[0. 0. 1.]     # [0. 0. 1.] --> 1
    [0. 0. 3.]     # [0. 0. 2.] --> 2
    [0. 0. 1.]     # [0. 0. 1.] --> 1
    [0. 0. 0.]     # [0. 0. 0.] --> 0
    [0. 2. 0.]]    # [0. 2. 0.] --> 2
                                --> [1, 2, 1, 0, 2]

위 과정을 거치면 x_test와 y_test의 데이터 형식이 딱 맞아 떨어지므로 평가지표를 사용할 수 있다.

---[ 해당 데이터에서 np.argmax 사용 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 - np.argmax 사용전
 
 print(y_predict)                           [np.argmax 변환 과정]
[[0.08959465 0.40775216 0.5026532 ]         # 3 번째가 크므로 인덱스 번호 2를 값으로 출력 
 [0.6018631  0.20704316 0.1910938 ]         # 1 번째가 크므로 인덱스 번호 0를 값으로 출력 
 [0.05926589 0.42458445 0.5161497 ]         # 3 번째가 크므로 인덱스 번호 2를 값으로 출력 
 [0.7170514  0.1463862  0.13656245]         # 1 번째가 크므로 인덱스 번호 0를 값으로 출력 
 [0.12393255 0.41218412 0.46388337]         # 3 번째가 크므로 인덱스 번호 2를 값으로 출력 
 [0.08613694 0.420794   0.49306896]         # 3 번째가 크므로 인덱스 번호 2를 값으로 출력 
 [0.67692095 0.16824727 0.1548318 ]         # 1 번째가 크므로 인덱스 번호 0를 값으로 출력 
 [0.6098877  0.2085307  0.18158153]         # 1 번째가 크므로 인덱스 번호 0를 값으로 출력 
 [0.09759078 0.41284874 0.48956054]    
 [0.60590327 0.20843604 0.18566066]  
 [0.66474    0.17617877 0.15908115]   
 [0.10766347 0.39219874 0.50013775]   
 [0.61376274 0.20040715 0.18583015]    
 [0.65335655 0.18506946 0.16157399]  
 [0.11661515 0.40082452 0.48256028]   
 [0.18119797 0.40600768 0.41279435]    
 [0.18567011 0.4207091  0.39362076]    
 [0.13218799 0.41507173 0.4527403 ]   
 [0.06576469 0.43045685 0.5037784 ]   
 [0.1014626  0.40981135 0.48872608]   
 [0.08630467 0.42224053 0.49145478]   
 [0.64735985 0.18673591 0.16590428]  
 [0.11526372 0.41435182 0.47038448]    
 [0.5836079  0.21743628 0.19895582]    
 [0.18963948 0.40684822 0.40351236]   
 [0.10951906 0.40046728 0.49001375]    
 [0.18905994 0.40474746 0.40619257]   
 [0.6187705  0.20348929 0.17774022]    
 [0.14006315 0.4194939  0.44044286]    
 [0.09492716 0.40226743 0.5028055 ]]    


- np.argmax 사용후

y_predict = np.argmax(y_predict, axis=1)

print(y_predict)
[2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 2 1 2 2 2 2 0 2 0 1 2 2 0 2 2]

---[ y_test도 평가지표에서 사용 가능하도록 np.argmax 과정을 거쳐야함 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

TMI!!  : 평가지표에서 사용할 수 있는 데이터는 [0. 0. 1.]형태가 아닌 무조건 [2 0 2 0 2 2 0 0]와 같은 형태로 되어야 하므로
                                     [1. 0. 0.]               y_test의 데이터의 형태를 변환해야한다.
                                     [0. 0. 1.] 

y_test의 np.argmax 사용전 
                                     
[[0. 0. 1.]                          
 [1. 0. 0.]
 [0. 0. 1.]
 [1. 0. 0.]
 [0. 0. 1.]
 [0. 0. 1.]
 [1. 0. 0.]
 [1. 0. 0.]
 [0. 0. 1.]
 [1. 0. 0.]
 [1. 0. 0.]
 [0. 0. 1.]
 [1. 0. 0.]
 [1. 0. 0.]
 [0. 0. 1.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 1. 0.]
 [0. 0. 1.]
 [0. 0. 1.]
 [0. 0. 1.]
 [1. 0. 0.]
 [0. 0. 1.]
 [1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]
 [0. 1. 0.]
 [1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

--[ y_test의 np.argmax 사용후 ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

y_test = np.argmax(y_test, axis=1)

print(y_test)
[2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 1 1 1 2 2 2 0 2 0 1 2 1 0 1 2]


--[ 최종 y_test와 y_predict의 데이터 ]- - - - - - - - - - - - - -

print(y_predict)
[2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 2 1 2 2 2 2 0 2 0 1 2 2 0 2 2]
print(y_test)
[2 0 2 0 2 2 0 0 2 0 0 2 0 0 2 1 1 1 2 2 2 0 2 0 1 2 1 0 1 2]

이 형태만 평가지표에서 사용가능하다.

"""



